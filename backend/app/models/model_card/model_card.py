import json
import logging
from pathlib import Path
from typing import Any

from pydantic import BaseModel

logger = logging.getLogger(__name__)

# Path to the model card configs directory
_CONFIG_DIR = Path(__file__).parent.parent.parent / "config" / "model_cards"


# ----- Pydantic Models -----
class ModelMetrics(BaseModel):
    accuracy: float | None = None
    precision: float | None = None
    recall: float | None = None
    f1_score: float | None = None
    roc_auc: float | None = None


class ModelFeature(BaseModel):
    name: str
    description: str = ""


class ModelCard(BaseModel):
    name: str
    version: str
    last_updated: str
    model_type: str
    features: list[ModelFeature]
    metrics: ModelMetrics | None = None
    intended_use: list[str]
    not_intended_for: list[str]
    limitations: list[str]
    recommendations: list[str]
    metadata: dict[str, Any] | None = None


# ----- Load Function -----
def _get_active_config_path() -> Path:
    """Return path to the currently active model card JSON config."""
    active_file = _CONFIG_DIR / "active_version.txt"
    if active_file.exists():
        version = active_file.read_text().strip()
        path = _CONFIG_DIR / f"{version}.json"
        if path.exists():
            return path
        logger.warning("active_version.txt points to '%s' but file not found.", version)

    # Fallback: most recent JSON in the directory
    candidates = sorted(_CONFIG_DIR.glob("v*.json"), reverse=True)
    if candidates:
        logger.warning("Falling back to most recent config: %s", candidates[0].name)
        return candidates[0]

    raise FileNotFoundError(
        f"No model card JSON config found in {_CONFIG_DIR}. "
        "Create one using the template (model_card_template.json)."
    )


def load_model_card() -> ModelCard:
    """
    Load the active model card from the JSON config file.

    The active version is determined by ``config/model_cards/active_version.txt``.
    To switch models, update that file (or use the ModelCardManager helper).
    To create a new model card, copy ``model_card_template.json`` and fill it in.

    NOTE: The model card is NOT stored as a static file in the frontend.
    It is dynamically generated by the API route (``/api/v1/model-card``)
    from this JSON config and returned as Markdown text on each request.
    """
    config_path = _get_active_config_path()
    logger.info("Loading model card from: %s", config_path)

    with open(config_path, encoding="utf-8") as fh:
        cfg = json.load(fh)

    # --- Metrics (from JSON config) ---
    metrics = None
    if "metrics" in cfg and "test_set" in cfg["metrics"]:
        ts = cfg["metrics"]["test_set"]
        metrics = ModelMetrics(
            accuracy=ts.get("accuracy"),
            precision=ts.get("precision"),
            recall=ts.get("recall"),
            f1_score=ts.get("f1_score"),
            roc_auc=ts.get("roc_auc"),
        )

    # --- Features (from RF adapter â€” ground truth for the actual model) ---
    features: list[ModelFeature] = []
    try:
        from app.core.rf_dataset_adapter import EXPECTED_FEATURES_RF

        features = [
            ModelFeature(name=f, description="")
            for f in EXPECTED_FEATURES_RF
            if not f.startswith("_placeholder")
        ]
    except Exception as exc:
        logger.warning("Could not load EXPECTED_FEATURES_RF: %s", exc)
        features = [ModelFeature(name="Features not available", description="")]

    return ModelCard(
        name=cfg.get("name", "HEAR CI Prediction Model"),
        version=cfg.get("version", "v?"),
        last_updated=cfg.get("deployment_date", "unknown"),
        model_type=cfg.get("model_type", "Unknown"),
        features=features,
        metrics=metrics,
        intended_use=cfg.get("intended_use", []),
        not_intended_for=cfg.get("not_intended_for", []),
        limitations=cfg.get("limitations", []),
        recommendations=cfg.get("recommendations", []),
        metadata={
            "dataset_size": cfg.get("training", {}).get("dataset_size"),
            "features_count": cfg.get("training", {}).get("features_count"),
            "config_file": config_path.name,
        },
    )
