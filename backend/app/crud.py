import uuid

from sqlmodel import Session, select

from app.models import (
    Feedback,
    FeedbackCreate,
    Prediction,
    PredictionCreate,
    Patient,
    PatientCreate,
)


# ------------------------------------------------------------
# Feedback CRUD
# ------------------------------------------------------------
def create_feedback(session: Session, feedback_in: FeedbackCreate) -> Feedback:
    db_obj = Feedback(**feedback_in.model_dump())
    session.add(db_obj)
    session.commit()
    session.refresh(db_obj)
    return db_obj


def get_feedback(session: Session, feedback_id: uuid.UUID | str) -> Feedback | None:
    # Convert string to UUID if needed
    if isinstance(feedback_id, str):
        feedback_id = uuid.UUID(feedback_id)
    statement = select(Feedback).where(Feedback.id == feedback_id)
    result = session.exec(statement)
    return result.first()


def list_feedback(session: Session, limit: int = 100, offset: int = 0) -> list[Feedback]:
    statement = select(Feedback).offset(offset).limit(limit)
    return session.exec(statement).all()


# ------------------------------------------------------------
# Prediction CRUD
# ------------------------------------------------------------
def create_prediction(session: Session, prediction_in: PredictionCreate) -> Prediction:
    db_obj = Prediction(**prediction_in.model_dump())
    session.add(db_obj)
    session.commit()
    session.refresh(db_obj)
    return db_obj


def get_prediction(session: Session, prediction_id: uuid.UUID | str) -> Prediction | None:
    # Convert string to UUID if needed
    if isinstance(prediction_id, str):
        prediction_id = uuid.UUID(prediction_id)
    statement = select(Prediction).where(Prediction.id == prediction_id)
    result = session.exec(statement)
    return result.first()


def list_predictions(session: Session, limit: int = 100, offset: int = 0) -> list[Prediction]:
    statement = select(Prediction).offset(offset).limit(limit)
    return session.exec(statement).all()


# ------------------------------------------------------------
# Patient CRUD
# ------------------------------------------------------------
def create_patient(session: Session, patient_in: PatientCreate) -> Patient:
    db_obj = Patient(**patient_in.model_dump())
    session.add(db_obj)
    session.commit()
    session.refresh(db_obj)
    return db_obj


def get_patient(session: Session, patient_id: uuid.UUID | str) -> Patient | None:
    # Convert string to UUID if needed
    if isinstance(patient_id, str):
        patient_id = uuid.UUID(patient_id)
    statement = select(Patient).where(Patient.id == patient_id)
    result = session.exec(statement)
    return result.first()


def list_patients(session: Session, limit: int = 100, offset: int = 0) -> list[Patient]:
    statement = select(Patient).offset(offset).limit(limit)
    return session.exec(statement).all()


def search_patients_by_name(session: Session, q: str, limit: int = 100, offset: int = 0) -> list[Patient]:
    """Search patients by `display_name` using case-insensitive substring match.

    This is a lightweight DB-side search that requires the `display_name`
    column to be present on the `patient` table. It intentionally keeps the
    SQL simple (ILIKE) so it works with standard Postgres deployments; a
    trigram/GIN index can be added in the DB for better fuzzy performance.
    """
    stmt = select(Patient).where(Patient.display_name.ilike(f"%{q}%"))
    stmt = stmt.offset(offset).limit(limit)
    return session.exec(stmt).all()


def count_patients(session: Session) -> int:
    """Count total number of patients in database."""
    from sqlalchemy import func
    statement = select(func.count()).select_from(Patient)
    return session.exec(statement).one()


def update_patient(session: Session, patient_id: uuid.UUID | str, patient_update: dict) -> Patient | None:
    """Update a patient's fields (input_features, display_name, etc.).
    
    Args:
        session: Database session
        patient_id: UUID of the patient to update
        patient_update: Dictionary with fields to update (e.g., {"input_features": {...}, "display_name": "..."})
        
    Returns:
        Updated Patient object or None if not found
    """
    if isinstance(patient_id, str):
        patient_id = uuid.UUID(patient_id)
    
    patient = get_patient(session=session, patient_id=patient_id)
    if not patient:
        return None
    
    # Update only provided fields
    for key, value in patient_update.items():
        if hasattr(patient, key):
            setattr(patient, key, value)
    
    session.add(patient)
    session.commit()
    session.refresh(patient)
    return patient


def delete_patient(session: Session, patient_id: uuid.UUID | str) -> bool:
    """Delete a patient from the database (hard delete).
    
    Args:
        session: Database session
        patient_id: UUID of the patient to delete
        
    Returns:
        True if patient was deleted, False if not found
    """
    if isinstance(patient_id, str):
        patient_id = uuid.UUID(patient_id)
    
    patient = get_patient(session=session, patient_id=patient_id)
    if not patient:
        return False
    
    session.delete(patient)
    session.commit()
    return True
